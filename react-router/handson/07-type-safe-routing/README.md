# å‹å®‰å…¨ãªãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ 

**æ‰€è¦æ™‚é–“: 3æ™‚é–“**  
**ãƒ¬ãƒ™ãƒ«: ğŸ”´ ä¸Šç´š**

TypeScriptã‚’æ´»ç”¨ã—ã¦å‹å®‰å…¨ãªãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã—ã€é–‹ç™ºä½“é¨“ã¨ä¿å®ˆæ€§ã‚’å‘ä¸Šã•ã›ã‚‹æ‰‹æ³•ã‚’å­¦ã³ã¾ã™ã€‚

## ğŸ¯ å­¦ç¿’ç›®æ¨™

- TypeScriptã«ã‚ˆã‚‹å‹å®‰å…¨ãªãƒ«ãƒ¼ãƒˆå®šç¾©ã‚’ç†è§£ã™ã‚‹
- ãƒ‘ã‚¹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å‹å®‰å…¨æ€§ã‚’ç¢ºä¿ã™ã‚‹
- ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯ã«ã‚ˆã‚‹å‹å®‰å…¨ãªãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè£…ã™ã‚‹
- ãƒ«ãƒ¼ãƒˆã«åŸºã¥ã„ãŸå‹æ¨è«–ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã™ã‚‹
- å‹å®‰å…¨ãªãƒªãƒ³ã‚¯ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’ä½œæˆã™ã‚‹
- é–‹ç™ºæ™‚ã®å‹ã‚¨ãƒ©ãƒ¼æ¤œå‡ºã¨ãƒ©ãƒ³ã‚¿ã‚¤ãƒ æ¤œè¨¼ã‚’å®Ÿè£…ã™ã‚‹

## ğŸ—ï¸ ä½œã‚‹ã‚‚ã®

å‹å®‰å…¨ãªãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ï¼š
- å‹å®šç¾©ã•ã‚ŒãŸãƒ«ãƒ¼ãƒˆãƒãƒƒãƒ—
- å‹å®‰å…¨ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å–å¾—
- å‹ä»˜ããƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ãƒƒã‚¯
- è‡ªå‹•è£œå®Œå¯¾å¿œã®ãƒªãƒ³ã‚¯ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
- ãƒ©ãƒ³ã‚¿ã‚¤ãƒ æ¤œè¨¼æ©Ÿèƒ½
- å‹å®‰å…¨ãªãƒ­ãƒ¼ãƒ€ãƒ¼é–¢æ•°

## ğŸ“‹ å‰ææ¡ä»¶

- ã€ŒSPAã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã€ã‚’å®Œäº†ã—ã¦ã„ã‚‹ã“ã¨
- TypeScriptã®é«˜åº¦ãªå‹æ©Ÿèƒ½ï¼ˆUnion Typesã€Mapped Typesã€Conditional Typesãªã©ï¼‰ã®ç†è§£
- React Router v6ã®æ·±ã„ç†è§£

## ğŸš€ å§‹ã‚æ–¹

### ã‚¹ãƒ†ãƒƒãƒ— 1: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®æº–å‚™

```bash
cd starter
npm install
npm run dev
npm run type-check
```

### ã‚¹ãƒ†ãƒƒãƒ— 2: æ®µéšçš„ãªå®Ÿè£…

1. **Step 1**: ãƒ«ãƒ¼ãƒˆãƒãƒƒãƒ—ã®å‹å®šç¾©ã‚·ã‚¹ãƒ†ãƒ 
2. **Step 2**: å‹å®‰å…¨ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æŠ½å‡º
3. **Step 3**: ã‚«ã‚¹ã‚¿ãƒ ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ãƒƒã‚¯
4. **Step 4**: å‹å®‰å…¨ãªãƒªãƒ³ã‚¯ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
5. **Step 5**: ãƒ©ãƒ³ã‚¿ã‚¤ãƒ æ¤œè¨¼ã¨ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

### ã‚¹ãƒ†ãƒƒãƒ— 3: å®Ÿè£…é–‹å§‹

#### Step 1: ãƒ«ãƒ¼ãƒˆãƒãƒƒãƒ—ã®å‹å®šç¾©

**src/types/routes.ts**:

```tsx
// ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å‹å®šç¾©
export interface RouteParams {
  '/': {}
  '/login': {}
  '/signup': {}
  '/products': {}
  '/products/:id': { id: string }
  '/categories/:category': { category: string }
  '/categories/:category/:subcategory': { 
    category: string
    subcategory: string 
  }
  '/users/:userId/orders/:orderId': {
    userId: string
    orderId: string
  }
  '/admin': {}
  '/admin/users': {}
  '/admin/users/:id': { id: string }
  '/admin/users/:id/edit': { id: string }
  '/search': {}
  '/cart': {}
  '/checkout': {}
  '/profile': {}
  '/orders/:id': { id: string }
}

// ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å‹å®šç¾©
export interface RouteSearchParams {
  '/': {}
  '/products': {
    category?: string
    subcategory?: string
    sort?: 'price-low' | 'price-high' | 'rating' | 'newest'
    minPrice?: string
    maxPrice?: string
    brands?: string[]
    page?: string
  }
  '/search': {
    q: string
    category?: string
    page?: string
  }
  '/categories/:category': {
    sort?: 'price-low' | 'price-high' | 'rating' | 'newest'
    minPrice?: string
    maxPrice?: string
    page?: string
  }
  '/categories/:category/:subcategory': {
    sort?: 'price-low' | 'price-high' | 'rating' | 'newest'
    minPrice?: string
    maxPrice?: string
    page?: string
  }
  // ä»–ã®ãƒ«ãƒ¼ãƒˆã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
  [K in keyof RouteParams]: {}
}

// ãƒ«ãƒ¼ãƒˆãƒ‘ã‚¹ã®å‹
export type RoutePath = keyof RouteParams

// ç‰¹å®šã®ãƒ«ãƒ¼ãƒˆã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å–å¾—ã™ã‚‹å‹
export type RouteParamsFor<T extends RoutePath> = RouteParams[T]

// ç‰¹å®šã®ãƒ«ãƒ¼ãƒˆã®ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å–å¾—ã™ã‚‹å‹
export type RouteSearchParamsFor<T extends RoutePath> = T extends keyof RouteSearchParams 
  ? RouteSearchParams[T]
  : {}

// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä»˜ããƒ«ãƒ¼ãƒˆã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹å‹
export type HasParams<T extends RoutePath> = RouteParams[T] extends Record<string, never> 
  ? false 
  : true

// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒå¿…è¦ãªãƒ«ãƒ¼ãƒˆ
export type RouteWithParams = {
  [K in RoutePath]: HasParams<K> extends true ? K : never
}[RoutePath]

// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒä¸è¦ãªãƒ«ãƒ¼ãƒˆ
export type RouteWithoutParams = {
  [K in RoutePath]: HasParams<K> extends false ? K : never
}[RoutePath]
```

#### Step 2: å‹å®‰å…¨ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ•ãƒƒã‚¯

**src/hooks/useTypedParams.ts**:

```tsx
import { useParams } from 'react-router-dom'
import { RoutePath, RouteParamsFor } from '../types/routes'

export function useTypedParams<T extends RoutePath>(
  _route?: T  // å‹æ¨è«–ã®ãŸã‚ã®ãƒ’ãƒ³ãƒˆï¼ˆå®Ÿéš›ã«ã¯ä½¿ç”¨ã—ãªã„ï¼‰
): RouteParamsFor<T> {
  const params = useParams()
  
  // é–‹ç™ºç’°å¢ƒã§ã®ãƒ©ãƒ³ã‚¿ã‚¤ãƒ æ¤œè¨¼
  if (process.env.NODE_ENV === 'development') {
    validateParams(params)
  }
  
  return params as RouteParamsFor<T>
}

function validateParams(params: any) {
  // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®åŸºæœ¬çš„ãªæ¤œè¨¼
  for (const [key, value] of Object.entries(params)) {
    if (typeof value !== 'string' && value !== undefined) {
      console.warn(`Invalid parameter type for ${key}:`, typeof value, value)
    }
  }
}

// ä½¿ç”¨ä¾‹:
// const { id } = useTypedParams<'/products/:id'>() // id ã¯ stringå‹
// const { category, subcategory } = useTypedParams<'/categories/:category/:subcategory'>()
```

**src/hooks/useTypedSearchParams.ts**:

```tsx
import { useSearchParams } from 'react-router-dom'
import { useCallback } from 'react'
import { RoutePath, RouteSearchParamsFor } from '../types/routes'

export function useTypedSearchParams<T extends RoutePath>(
  _route?: T
) {
  const [searchParams, setSearchParams] = useSearchParams()
  
  // å‹å®‰å…¨ãªgetter
  const getSearchParam = useCallback(<K extends keyof RouteSearchParamsFor<T>>(
    key: K
  ): RouteSearchParamsFor<T>[K] => {
    const value = searchParams.get(key as string)
    
    // é…åˆ—ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å‡¦ç†
    if (key === 'brands') {
      return searchParams.getAll(key as string) as RouteSearchParamsFor<T>[K]
    }
    
    return value as RouteSearchParamsFor<T>[K]
  }, [searchParams])
  
  // å‹å®‰å…¨ãªsetter
  const setSearchParam = useCallback(<K extends keyof RouteSearchParamsFor<T>>(
    key: K,
    value: RouteSearchParamsFor<T>[K] | null
  ) => {
    const newParams = new URLSearchParams(searchParams)
    
    if (value === null || value === undefined) {
      newParams.delete(key as string)
    } else if (Array.isArray(value)) {
      // é…åˆ—ã®å ´åˆã¯å…¨ã¦å‰Šé™¤ã—ã¦ã‹ã‚‰è¿½åŠ 
      newParams.delete(key as string)
      value.forEach(v => newParams.append(key as string, v))
    } else {
      newParams.set(key as string, value as string)
    }
    
    setSearchParams(newParams)
  }, [searchParams, setSearchParams])
  
  // è¤‡æ•°ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ä¸€æ‹¬è¨­å®š
  const setSearchParams_ = useCallback((
    params: Partial<RouteSearchParamsFor<T>>
  ) => {
    const newParams = new URLSearchParams()
    
    Object.entries(params).forEach(([key, value]) => {
      if (value !== null && value !== undefined) {
        if (Array.isArray(value)) {
          value.forEach(v => newParams.append(key, v))
        } else {
          newParams.set(key, value as string)
        }
      }
    })
    
    setSearchParams(newParams)
  }, [setSearchParams])
  
  // å‹å®‰å…¨ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å–å¾—
  const getSearchParams = useCallback((): Partial<RouteSearchParamsFor<T>> => {
    const result: any = {}
    
    // æ—¢çŸ¥ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ã¿ã‚’æŠ½å‡º
    for (const [key, value] of searchParams.entries()) {
      if (result[key]) {
        // é…åˆ—åŒ–
        if (Array.isArray(result[key])) {
          result[key].push(value)
        } else {
          result[key] = [result[key], value]
        }
      } else {
        result[key] = value
      }
    }
    
    return result
  }, [searchParams])
  
  return {
    getSearchParam,
    setSearchParam,
    setSearchParams: setSearchParams_,
    getSearchParams,
    searchParams // å…ƒã®URLSearchParamsã‚‚æä¾›
  }
}
```

#### Step 3: å‹å®‰å…¨ãªãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ãƒƒã‚¯

**src/hooks/useTypedNavigate.ts**:

```tsx
import { useNavigate, NavigateOptions } from 'react-router-dom'
import { useCallback } from 'react'
import { 
  RoutePath, 
  RouteParamsFor, 
  RouteSearchParamsFor, 
  HasParams,
  RouteWithParams,
  RouteWithoutParams
} from '../types/routes'

// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒä¸è¦ãªãƒ«ãƒ¼ãƒˆç”¨ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰
export function useTypedNavigate(): {
  navigate<T extends RouteWithoutParams>(
    to: T,
    options?: NavigateOptions & {
      searchParams?: Partial<RouteSearchParamsFor<T>>
    }
  ): void
  
  // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒå¿…è¦ãªãƒ«ãƒ¼ãƒˆç”¨ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰
  navigate<T extends RouteWithParams>(
    to: T,
    params: RouteParamsFor<T>,
    options?: NavigateOptions & {
      searchParams?: Partial<RouteSearchParamsFor<T>>
    }
  ): void
  
  // æ•°å€¤ã§ã®ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆæˆ»ã‚‹/é€²ã‚€ï¼‰
  navigate(delta: number): void
}

export function useTypedNavigate() {
  const navigate = useNavigate()
  
  const typedNavigate = useCallback(
    (
      to: RoutePath | number,
      paramsOrOptions?: any,
      options?: NavigateOptions & { searchParams?: any }
    ) => {
      // æ•°å€¤ã®å ´åˆã¯ãã®ã¾ã¾æ¸¡ã™
      if (typeof to === 'number') {
        navigate(to)
        return
      }
      
      let finalPath = to as string
      let finalOptions = options
      
      // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒæ¸¡ã•ã‚ŒãŸå ´åˆã®å‡¦ç†
      if (paramsOrOptions && typeof paramsOrOptions === 'object' && !('replace' in paramsOrOptions)) {
        // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒæ¸¡ã•ã‚ŒãŸå ´åˆ
        const params = paramsOrOptions
        finalOptions = options
        
        // ãƒ‘ã‚¹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ç½®æ›
        for (const [key, value] of Object.entries(params)) {
          finalPath = finalPath.replace(`:${key}`, encodeURIComponent(value as string))
        }
      } else {
        // ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ã¿ãŒæ¸¡ã•ã‚ŒãŸå ´åˆ
        finalOptions = paramsOrOptions
      }
      
      // ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’è¿½åŠ 
      if (finalOptions?.searchParams) {
        const searchParams = new URLSearchParams()
        
        Object.entries(finalOptions.searchParams).forEach(([key, value]) => {
          if (value !== null && value !== undefined) {
            if (Array.isArray(value)) {
              value.forEach(v => searchParams.append(key, v))
            } else {
              searchParams.set(key, value as string)
            }
          }
        })
        
        const queryString = searchParams.toString()
        if (queryString) {
          finalPath += '?' + queryString
        }
      }
      
      // ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‹ã‚‰searchParamsã‚’é™¤å»
      const { searchParams, ...navigateOptions } = finalOptions || {}
      
      navigate(finalPath, navigateOptions)
    },
    [navigate]
  )
  
  return { navigate: typedNavigate }
}

// ä½¿ç”¨ä¾‹:
// const { navigate } = useTypedNavigate()
// 
// navigate('/products')  // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä¸è¦
// navigate('/products/:id', { id: '123' })  // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å¿…è¦
// navigate('/search', { searchParams: { q: 'query', category: 'books' } })
```

#### Step 4: å‹å®‰å…¨ãªãƒªãƒ³ã‚¯ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

**src/components/TypedLink.tsx**:

```tsx
import React, { AnchorHTMLAttributes, forwardRef } from 'react'
import { Link, LinkProps } from 'react-router-dom'
import { 
  RoutePath, 
  RouteParamsFor, 
  RouteSearchParamsFor,
  RouteWithParams,
  RouteWithoutParams
} from '../types/routes'

// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒä¸è¦ãªãƒ«ãƒ¼ãƒˆç”¨
type TypedLinkPropsWithoutParams<T extends RouteWithoutParams> = Omit<LinkProps, 'to'> & {
  to: T
  params?: never
  searchParams?: Partial<RouteSearchParamsFor<T>>
}

// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒå¿…è¦ãªãƒ«ãƒ¼ãƒˆç”¨
type TypedLinkPropsWithParams<T extends RouteWithParams> = Omit<LinkProps, 'to'> & {
  to: T
  params: RouteParamsFor<T>
  searchParams?: Partial<RouteSearchParamsFor<T>>
}

// çµ±åˆã•ã‚ŒãŸå‹
type TypedLinkProps<T extends RoutePath> = T extends RouteWithoutParams 
  ? TypedLinkPropsWithoutParams<T>
  : T extends RouteWithParams 
  ? TypedLinkPropsWithParams<T>
  : never

function TypedLinkComponent<T extends RoutePath>(
  props: TypedLinkProps<T>,
  ref: React.Ref<HTMLAnchorElement>
) {
  const { to, params, searchParams, ...linkProps } = props
  
  // ãƒ‘ã‚¹ã‚’æ§‹ç¯‰
  let finalPath = to as string
  
  // ãƒ‘ã‚¹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ç½®æ›
  if (params) {
    for (const [key, value] of Object.entries(params)) {
      finalPath = finalPath.replace(`:${key}`, encodeURIComponent(value as string))
    }
  }
  
  // ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’è¿½åŠ 
  if (searchParams && Object.keys(searchParams).length > 0) {
    const urlSearchParams = new URLSearchParams()
    
    Object.entries(searchParams).forEach(([key, value]) => {
      if (value !== null && value !== undefined) {
        if (Array.isArray(value)) {
          value.forEach(v => urlSearchParams.append(key, v))
        } else {
          urlSearchParams.set(key, value as string)
        }
      }
    })
    
    const queryString = urlSearchParams.toString()
    if (queryString) {
      finalPath += '?' + queryString
    }
  }
  
  return <Link ref={ref} to={finalPath} {...linkProps} />
}

export const TypedLink = forwardRef(TypedLinkComponent) as <T extends RoutePath>(
  props: TypedLinkProps<T> & { ref?: React.Ref<HTMLAnchorElement> }
) => ReactElement

// ä½¿ç”¨ä¾‹ã®ãŸã‚ã®å‹å®šç¾©
type ReactElement = React.ReactElement<any, any>

// ä¾¿åˆ©ãªãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
export function ProductLink({ 
  productId, 
  children, 
  ...props 
}: { 
  productId: string 
  children: React.ReactNode 
} & Omit<TypedLinkPropsWithParams<'/products/:id'>, 'to' | 'params' | 'children'>) {
  return (
    <TypedLink to="/products/:id" params={{ id: productId }} {...props}>
      {children}
    </TypedLink>
  )
}

export function CategoryLink({ 
  category, 
  subcategory,
  children, 
  ...props 
}: { 
  category: string
  subcategory?: string
  children: React.ReactNode 
} & Omit<LinkProps, 'to' | 'children'>) {
  const to = subcategory 
    ? '/categories/:category/:subcategory' as const
    : '/categories/:category' as const
    
  const params = subcategory 
    ? { category, subcategory }
    : { category }
  
  return (
    <TypedLink to={to} params={params as any} {...props}>
      {children}
    </TypedLink>
  )
}
```

#### Step 5: ãƒ©ãƒ³ã‚¿ã‚¤ãƒ æ¤œè¨¼ã¨ãƒ‡ãƒãƒƒã‚°æ”¯æ´

**src/utils/routeValidation.ts**:

```tsx
import { RoutePath, RouteParams } from '../types/routes'

// ãƒ«ãƒ¼ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³ã‹ã‚‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åã‚’æŠ½å‡º
export function extractParamNames(route: string): string[] {
  const matches = route.match(/:(\w+)/g)
  return matches ? matches.map(match => match.substring(1)) : []
}

// ãƒ«ãƒ¼ãƒˆã¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ¤œè¨¼
export function validateRouteParams<T extends RoutePath>(
  route: T,
  params: any
): params is RouteParams[T] {
  const expectedParams = extractParamNames(route)
  const providedParams = Object.keys(params || {})
  
  // ä¸è¶³ã—ã¦ã„ã‚‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ãƒã‚§ãƒƒã‚¯
  const missingParams = expectedParams.filter(param => !providedParams.includes(param))
  if (missingParams.length > 0) {
    console.error(`Missing required parameters for route ${route}:`, missingParams)
    return false
  }
  
  // ä½™åˆ†ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ãƒã‚§ãƒƒã‚¯
  const extraParams = providedParams.filter(param => !expectedParams.includes(param))
  if (extraParams.length > 0) {
    console.warn(`Extra parameters provided for route ${route}:`, extraParams)
  }
  
  return true
}

// é–‹ç™ºæ™‚ã®ãƒ«ãƒ¼ãƒˆãƒ‡ãƒãƒƒã‚°ãƒ˜ãƒ«ãƒ‘ãƒ¼
export function debugRoute(route: RoutePath, params?: any, searchParams?: any) {
  if (process.env.NODE_ENV !== 'development') return
  
  console.group(`ğŸ›£ï¸ Route Debug: ${route}`)
  console.log('Expected params:', extractParamNames(route))
  console.log('Provided params:', params)
  console.log('Search params:', searchParams)
  console.log('Valid:', validateRouteParams(route, params))
  console.groupEnd()
}
```

**src/components/RouteDebugger.tsx** (é–‹ç™ºæ™‚ã®ã¿è¡¨ç¤º):

```tsx
import { useLocation, useParams } from 'react-router-dom'
import { useTypedSearchParams } from '../hooks/useTypedSearchParams'

function RouteDebugger() {
  const location = useLocation()
  const params = useParams()
  const { searchParams } = useTypedSearchParams()
  
  if (process.env.NODE_ENV !== 'development') return null
  
  return (
    <div className="fixed bottom-4 right-4 bg-gray-900 text-white p-4 rounded-lg shadow-lg text-sm max-w-md z-50">
      <div className="font-bold mb-2">ğŸ›£ï¸ Route Debugger</div>
      <div><strong>Path:</strong> {location.pathname}</div>
      <div><strong>Params:</strong> {JSON.stringify(params)}</div>
      <div><strong>Search:</strong> {searchParams.toString()}</div>
      <div><strong>Hash:</strong> {location.hash}</div>
      <div><strong>State:</strong> {JSON.stringify(location.state)}</div>
    </div>
  )
}

export default RouteDebugger
```

#### Step 6: å®Ÿéš›ã®ä½¿ç”¨ä¾‹

**src/pages/TypeSafeProductList.tsx**:

```tsx
import { useTypedParams } from '../hooks/useTypedParams'
import { useTypedSearchParams } from '../hooks/useTypedSearchParams'
import { useTypedNavigate } from '../hooks/useTypedNavigate'
import { TypedLink, CategoryLink } from '../components/TypedLink'

function TypeSafeProductList() {
  // å‹å®‰å…¨ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å–å¾—
  const { category, subcategory } = useTypedParams<'/categories/:category/:subcategory'>()
  
  // å‹å®‰å…¨ãªã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
  const { 
    getSearchParam, 
    setSearchParam, 
    getSearchParams 
  } = useTypedSearchParams<'/categories/:category/:subcategory'>()
  
  const { navigate } = useTypedNavigate()
  
  const currentSort = getSearchParam('sort') // å‹: 'price-low' | 'price-high' | 'rating' | 'newest' | undefined
  const currentPage = getSearchParam('page') // å‹: string | undefined
  const minPrice = getSearchParam('minPrice') // å‹: string | undefined
  
  const handleSortChange = (sort: 'price-low' | 'price-high' | 'rating' | 'newest') => {
    setSearchParam('sort', sort)
    setSearchParam('page', null) // ãƒšãƒ¼ã‚¸ã‚’ãƒªã‚»ãƒƒãƒˆ
  }
  
  const handleCategoryChange = (newCategory: string, newSubcategory?: string) => {
    if (newSubcategory) {
      navigate('/categories/:category/:subcategory', {
        category: newCategory,
        subcategory: newSubcategory
      }, {
        searchParams: getSearchParams() // ç¾åœ¨ã®æ¤œç´¢ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ç¶­æŒ
      })
    } else {
      navigate('/categories/:category', {
        category: newCategory
      }, {
        searchParams: getSearchParams()
      })
    }
  }
  
  return (
    <div>
      <h1>å•†å“ä¸€è¦§: {category} {subcategory && `> ${subcategory}`}</h1>
      
      {/* å‹å®‰å…¨ãªãƒªãƒ³ã‚¯ */}
      <nav>
        <TypedLink to="/categories/:category" params={{ category: 'electronics' }}>
          é›»å­æ©Ÿå™¨
        </TypedLink>
        
        <CategoryLink category="books" subcategory="programming">
          ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°æ›¸ç±
        </CategoryLink>
      </nav>
      
      {/* ã‚½ãƒ¼ãƒˆæ©Ÿèƒ½ */}
      <select 
        value={currentSort || 'newest'}
        onChange={(e) => handleSortChange(e.target.value as any)}
      >
        <option value="newest">æ–°ç€é †</option>
        <option value="price-low">ä¾¡æ ¼ã®å®‰ã„é †</option>
        <option value="price-high">ä¾¡æ ¼ã®é«˜ã„é †</option>
        <option value="rating">è©•ä¾¡ã®é«˜ã„é †</option>
      </select>
      
      {/* å•†å“ä¸€è¦§... */}
    </div>
  )
}

export default TypeSafeProductList
```

## ğŸ“ å­¦ç¿’ãƒã‚¤ãƒ³ãƒˆ

### 1. å‹å®‰å…¨ãªãƒ«ãƒ¼ãƒˆå®šç¾©
```tsx
interface RouteParams {
  '/products/:id': { id: string }
  '/categories/:category/:subcategory': { 
    category: string
    subcategory: string 
  }
}
```

### 2. å‹æ¨è«–ã«ã‚ˆã‚‹è‡ªå‹•è£œå®Œ
```tsx
const { id } = useTypedParams<'/products/:id'>() // idã¯stringå‹
const sort = getSearchParam('sort') // å®šç¾©ã•ã‚ŒãŸå‹ã®Unionå‹
```

### 3. ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã®å‹ãƒã‚§ãƒƒã‚¯
```tsx
// âœ… æ­£ã—ã„ä½¿ç”¨æ³•
navigate('/products/:id', { id: '123' })

// âŒ ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼
navigate('/products/:id') // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒä¸è¶³
navigate('/products/:id', { wrongParam: '123' }) // é–“é•ã£ãŸãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
```

### 4. ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã«ã‚ˆã‚‹å‹å®‰å…¨æ€§
```tsx
// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä¸è¦ãªãƒ«ãƒ¼ãƒˆ
navigate('/products')

// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å¿…è¦ãªãƒ«ãƒ¼ãƒˆ  
navigate('/products/:id', { id: '123' })
```

## ğŸ§ª ãƒãƒ£ãƒ¬ãƒ³ã‚¸èª²é¡Œ

### ãƒãƒ£ãƒ¬ãƒ³ã‚¸ 1: å‹å®‰å…¨ãªãƒ•ã‚©ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°
ãƒ•ã‚©ãƒ¼ãƒ ã®é€ä¿¡å…ˆURLã‚’å‹å®‰å…¨ã«ç®¡ç†ã™ã‚‹ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã—ã¦ãã ã•ã„ã€‚

### ãƒãƒ£ãƒ¬ãƒ³ã‚¸ 2: å‹•çš„ãƒ«ãƒ¼ãƒˆç”Ÿæˆ
è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å‹•çš„ã«ãƒ«ãƒ¼ãƒˆå®šç¾©ã‚’ç”Ÿæˆã—ã€å‹å®‰å…¨æ€§ã‚’ä¿ã¤ã‚·ã‚¹ãƒ†ãƒ ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„ã€‚

### ãƒãƒ£ãƒ¬ãƒ³ã‚¸ 3: Multi-languageå¯¾å¿œ
å¤šè¨€èªå¯¾å¿œã®ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã‚’å‹å®‰å…¨ã«å®Ÿè£…ã—ã¦ãã ã•ã„ã€‚

## ğŸ‰ å®Œäº†ï¼

ãŠç–²ã‚Œæ§˜ã§ã—ãŸï¼React Routerã®7ã¤ã®ãƒãƒ³ã‚ºã‚ªãƒ³ã‚’ã™ã¹ã¦å®Œäº†ã•ã‚Œã¾ã—ãŸã€‚

### ğŸ“ ç¿’å¾—ã—ãŸã‚¹ã‚­ãƒ«

- **åŸºç¤**: ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã€Linkã€useNavigate
- **å¿œç”¨**: å‹•çš„ãƒ«ãƒ¼ãƒˆã€ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã€ãƒã‚¹ãƒˆãƒ«ãƒ¼ãƒˆ
- **å®Ÿè·µ**: èªè¨¼ã€è¤‡é›‘ãªECã‚µã‚¤ãƒˆæ§‹é€ 
- **ä¸Šç´š**: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã€å‹å®‰å…¨æ€§

ã“ã‚Œã‚‰ã®çŸ¥è­˜ã‚’æ´»ã‹ã—ã¦ã€ã‚ˆã‚Šé«˜åº¦ãªWebã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ§‹ç¯‰ã—ã¦ãã ã•ã„ï¼